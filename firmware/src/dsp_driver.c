/* SPDX-License-Identifier: MIT */
#include "em_timer.h"
#include "em_adc.h"
#include "em_cmu.h"
#include "em_gpio.h"
#include "em_opamp.h"
#include "em_vdac.h"
#include "InitDevice.h"

#include "rail.h"

#include "FreeRTOS.h"
#include "queue.h"

#include "dsp.h"
#include "dsp_driver.h"

#include <stdio.h>

/* Signal flow during reception
 * ----------------------------
 * Audio output is a PWM output driven by a timer.
 * I/Q input is read from the RAIL RX FIFO.
 * Audio output sample rate should have a known relationship
 * to the I/Q input sample rate.
 * To ensure the input and output streams keep synchronized, they
 * are driven by the same interrupt handler, which is the
 * RAIL RX FIFO event callback handler.
 * Every time a block of I/Q samples is received, one audio sample
 * is updated to the PWM value. Thus, the I/Q sample rate should
 * be an integer multiple of the audio sample rate.
 *
 * To avoid jitter and aliasing effects, the audio sample rate
 * should be synchronized to the PWM frequency, so that each
 * audio sample affects a constant number of PWM cycles.
 * Some attention should be paid to the effect of interrupt
 * timing jitter in updating the PWM value.
 * (This part is not done yet.)
 *
 * Software interfaces
 * -------------------
 * The callback handler interfaces to the fast DSP task
 * through a ring buffer and an RTOS queue.
 * Each queue item contains the number of samples to process
 * and pointers to input and output buffers.
 * The fast DSP task calls dsp_fast_rx with these buffers
 * to do the actual signal processing.
 * The fast DSP task can further defer processing to the
 * slow DSP task by buffering data and sending messages
 * using an RTOS queue.
 *
 * Signal flow during transmission
 * -------------------------------
 * Audio input comes from the integrated ADC.
 * Transmitted signal is generated by writing the channel register
 * of the frequency synthesizer, so a frequency modulated signal
 * is transmitted.
 * Both the audio input and frequency modulation output are
 * handled in the ADC interrupt handler, and they have the same
 * sampling rate.
 *
 */

/* -------------------------
 * Buffer size configuration
 * ------------------------- */

/* Ratio of I/Q input and audio output sample rates.
 * This determines the number of samples to read
 * at a time from the RAIL FIFO. */
#define RX_SAMPLE_RATIO 2

/* How many samples to process at a time in the DSP task.
 * This is the number of audio samples, so number of I/Q
 * samples is RX_SAMPLE_RATIO times the value. */
#define RX_DSP_BLOCK 32

/* Size of the RX ring buffer as a multiple of block size. */
#define RX_BUF_BLOCKS 2

/* How many transmit samples to process at a time */
#define TX_DSP_BLOCK 32

/* Size of the TX ring buffer as a multiple of block size. */
#define TX_BUF_BLOCKS 2


// TODO: move this in some common plane as it's also in railtask.c
#define MIDDLECHANNEL 32

/* ----------------------
 * Buffers and data types
 * ---------------------- */

/* Diagnostics, could be moved to some more global place */
struct diagnostics {
	uint32_t rx_blocks_overflow, rx_blocks_isr, rx_blocks_task;
	uint32_t rx_rail_underruns, rx_samples_isr;
	uint32_t tx_blocks_overflow, tx_blocks_isr, tx_blocks_task;

	// Cycle counters to estimate CPU usage of fast DSP
	uint32_t cycles_dsp, cycles_nodsp;
};
struct diagnostics diag;


/* Receive-related buffers */
audio_out_t buf_audio_out[RX_DSP_BLOCK * RX_BUF_BLOCKS];
iq_in_t buf_iq_in[RX_DSP_BLOCK * RX_BUF_BLOCKS * RX_SAMPLE_RATIO];
unsigned rx_buf_p = 0;

/* Transmit-related buffers */
audio_in_t buf_audio_in[TX_DSP_BLOCK * TX_BUF_BLOCKS];
fm_out_t buf_fm_out[TX_DSP_BLOCK * TX_BUF_BLOCKS];
unsigned tx_buf_p = 0;

/* Message sent from interrupt to fast DSP task during receive */
struct fast_dsp_rx_msg {
	iq_in_t *in;
	audio_out_t *out;
	uint16_t in_len, out_len;
};

/* Message sent from interrupt to fast DSP task during transmit */
struct fast_dsp_tx_msg {
	audio_in_t *in;
	fm_out_t *out;
	uint16_t len;
};

/* Queues to communicate between interrupts and fast DSP task */
QueueHandle_t fast_dsp_rx_q, fast_dsp_tx_q;
QueueSetHandle_t fast_dsp_qs;


/* ----------------
 * Driver functions
 * ---------------- */

/* rail_callback is called from a RAIL interrupt handler */
void rail_callback(RAIL_Handle_t rail, RAIL_Events_t events)
{
	BaseType_t yield = 0;
	if (events & RAIL_EVENT_RX_FIFO_ALMOST_FULL) {
		unsigned nread, p = rx_buf_p;

		uint32_t audio_out = buf_audio_out[p];
		TIMER_CompareBufSet(TIMER0, 0, audio_out);
#ifdef USE_OPAMPS
		// DAC has more resolution than PWM so really bit depth
		// should be increased in DSP code, but for now just scale
		// it to use most of DAC range.
		VDAC_Channel1OutputSet(VDAC0, audio_out * 20);
#endif

		nread = RAIL_ReadRxFifo(rail, (uint8_t*)(buf_iq_in + p * RX_SAMPLE_RATIO), sizeof(iq_in_t) * RX_SAMPLE_RATIO);
		if (nread != sizeof(iq_in_t) * RX_SAMPLE_RATIO)
			++diag.rx_rail_underruns;
		++diag.rx_samples_isr;

		if (p % RX_DSP_BLOCK == RX_DSP_BLOCK - 1) {
			// Index of the first sample in the latest received block
			unsigned fp = p - (RX_DSP_BLOCK - 1);

			struct fast_dsp_rx_msg msg = {
				buf_iq_in + fp * RX_SAMPLE_RATIO,
				buf_audio_out + fp,
				RX_DSP_BLOCK * RX_SAMPLE_RATIO,
				RX_DSP_BLOCK
			};
			if (xQueueSendFromISR(fast_dsp_rx_q, &msg, &yield))
				++diag.rx_blocks_isr;
			else
				++diag.rx_blocks_overflow;
		}

		if (++p >= RX_DSP_BLOCK * RX_BUF_BLOCKS)
			p = 0;
		rx_buf_p = p;
	}
	portYIELD_FROM_ISR(yield);
}


/* Set frequency synthesizer channel */
static inline void synth_set_channel(uint32_t ch)
{
	*(uint32_t*)0x40083038 = ch;
}


/* ADC interrupt, used for transmission */
void ADC0_IRQHandler() {
	BaseType_t yield = 0;
	unsigned p = tx_buf_p;
	synth_set_channel(buf_fm_out[p]);
	buf_audio_in[p] = ADC0->SINGLEDATA;

	if (p % TX_DSP_BLOCK == TX_DSP_BLOCK - 1) {
		unsigned fp = p - (TX_DSP_BLOCK - 1);

		struct fast_dsp_tx_msg msg = {
			buf_audio_in + fp,
			buf_fm_out + fp,
			TX_DSP_BLOCK
		};
		if (xQueueSendFromISR(fast_dsp_tx_q, &msg, &yield))
			++diag.tx_blocks_isr;
		else
			++diag.tx_blocks_overflow;
	}

	if (++p >= TX_DSP_BLOCK * TX_BUF_BLOCKS)
		p = 0;
	tx_buf_p = p;

	ADC_IntClear(ADC0, ADC_IF_SINGLE);
	portYIELD_FROM_ISR(yield);
}


void setup_opamps(void)
{
#ifdef USE_OPAMPS
	// VDAC0 is used for both speaker and microphone.
	// Channel 0 biases microphone input opamp.
	// Channel 1 is audio output.
	CMU_ClockEnable(cmuClock_VDAC0, true);
	VDAC_Init(VDAC0, &(const VDAC_Init_TypeDef){
		.mainCalibration = true,
		.asyncClockMode = false,
		.warmupKeepOn = true,
		.refresh = vdacRefresh8,
		.prescaler = 0,
		.reference = vdacRef1V25Ln,
		.ch0ResetPre = false,
		.outEnablePRS = false,
		.sineEnable = false,
		.diff = false,
	});

	VDAC_Channel0OutputSet(VDAC0, 0x800);
	VDAC_Channel1OutputSet(VDAC0, 0x800);
	VDAC_Enable(VDAC0, 1, true);

	OPAMP_Enable(VDAC0, OPA1, &(const OPAMP_Init_TypeDef){
		.negSel = opaNegSelResTap,
		.posSel = opaPosSelDac,
		.outMode =  opaOutModeMain, // PD14
		.resSel = opaResSelR2eqR1,
		.resInMux = opaResInMuxVss,
		.outPen = VDAC_OPA_OUT_MAINOUTEN,
		.drvStr = opaDrvStrHighAccHighStr, // maybe adjust later to optimize power consumption
		.gain3xEn = false,
		.halfDrvStr = false,
		.ugBwScale = false,
		.prsEn = false,
		.prsMode = opaPrsModeDefault,
		.prsSel = opaPrsSelDefault,
		.prsOutSel = opaPrsOutDefault,
		.aportYMasterDisable = false,
		.aportXMasterDisable = false,
		.settleTime = 3, // from OPA_INIT_INVERTING defaults
		.startupDly = 0,
		.hcmDisable = false,
		.defaultOffsetN = true,
		.offsetN = 0,
		.defaultOffsetP = true,
		.offsetP = 0,
	});

	OPAMP_Enable(VDAC0, OPA0, &(const OPAMP_Init_TypeDef){
		.negSel = opaNegSelResTap,
		.posSel = opaPosSelDac,
		.outMode =  opaOutModeAPORT1YCH19, // PF3
		.resSel = opaResSelR2eqR1, // may be changed to adjust mic gain
		.resInMux = opaResInMuxNegPad,
		.outPen = VDAC_OPA_OUT_ALTOUTPADEN_OUT0, // TODO?
		.drvStr = opaDrvStrHighAccHighStr, // maybe adjust later to optimize power consumption
		.gain3xEn = false,
		.halfDrvStr = false,
		.ugBwScale = false,
		.prsEn = false,
		.prsMode = opaPrsModeDefault,
		.prsSel = opaPrsSelDefault,
		.prsOutSel = opaPrsOutDefault,
		.aportYMasterDisable = false,
		.aportXMasterDisable = false,
		.settleTime = 3, // from OPA_INIT_INVERTING defaults
		.startupDly = 0,
		.hcmDisable = false,
		.defaultOffsetN = true,
		.offsetN = 0,
		.defaultOffsetP = true,
		.offsetP = 0,
	});
#endif
}


int start_rx_dsp(RAIL_Handle_t rail)
{
	// TODO clear the audio buffer for first round
	unsigned r;
	ADC_IntDisable(ADC0, ADC_IF_SINGLE);
	// TODO: stop microphone ADC?
	RAIL_Idle(rail, RAIL_IDLE_ABORT, false);

#ifdef MIC_EN_PIN
	GPIO_PinOutClear(MIC_EN_PORT, MIC_EN_PIN);
#endif
#ifdef RX_EN_PIN
	GPIO_PinOutClear(TX_EN_PORT, TX_EN_PIN);
	GPIO_PinOutSet(RX_EN_PORT, RX_EN_PIN);
#endif
	RAIL_ResetFifo(rail, false, true);
	RAIL_SetRxFifoThreshold(rail, sizeof(iq_in_t) * RX_SAMPLE_RATIO);
	// Setting channel through RAIL does not always seem to work
	// after writing directly to the channel register,
	// so write the channel register too.
	synth_set_channel(MIDDLECHANNEL);
	r = RAIL_StartRx(rail, MIDDLECHANNEL, NULL);
	printf("RAIL_StartRx: %u\n", r);
	return r;
}


int start_tx_dsp(RAIL_Handle_t rail)
{
	(void)rail;
	// TODO clear the FM buffer for first round
#ifdef MIC_EN_PIN
	GPIO_PinOutSet(MIC_EN_PORT, MIC_EN_PIN);
#endif
#ifdef RX_EN_PIN
	GPIO_PinOutClear(RX_EN_PORT, RX_EN_PIN);
	GPIO_PinOutSet(TX_EN_PORT, TX_EN_PIN);
#endif
	RAIL_Idle(rail, RAIL_IDLE_ABORT, true);
	RAIL_StartTxStream(rail, MIDDLECHANNEL, RAIL_STREAM_CARRIER_WAVE);
	NVIC_EnableIRQ(ADC0_IRQn);
	ADC_IntEnable(ADC0, ADC_IF_SINGLE);
	ADC_Start(ADC0, adcStartSingle);
	return 0;
}


// Initialize hardware used for signal I/O.
void dsp_hw_init(void)
{
	// TODO: move other related hardware init code here
	setup_opamps();
#ifdef SPK_EN_PIN
	// Make the speaker pin open drain since it is pulled up
	// to a voltage higher than EFR32 supply.
	GPIO_PinModeSet(SPK_EN_PORT, SPK_EN_PIN, gpioModeWiredAnd, 0);
#endif
}


/* Create the RTOS objects needed by DSP.
 * Called before starting the scheduler. */
void dsp_rtos_init(void)
{
	fast_dsp_rx_q = xQueueCreate(RX_BUF_BLOCKS - 1, sizeof(struct fast_dsp_rx_msg));
	fast_dsp_tx_q = xQueueCreate(TX_BUF_BLOCKS - 1, sizeof(struct fast_dsp_tx_msg));
	fast_dsp_qs = xQueueCreateSet(RX_BUF_BLOCKS - 1 + TX_BUF_BLOCKS - 1);
	xQueueAddToSet(fast_dsp_rx_q, fast_dsp_qs);
	xQueueAddToSet(fast_dsp_tx_q, fast_dsp_qs);
}


void fast_dsp_task(void *arg)
{
	(void)arg;
	uint32_t cyc1, cyc2;
	dsp_update_params();
	cyc2 = DWT->CYCCNT;
	for (;;) {
		QueueHandle_t q;
		q = xQueueSelectFromSet(fast_dsp_qs, portMAX_DELAY);
		cyc1 = DWT->CYCCNT;
		diag.cycles_nodsp += cyc1 - cyc2;
		if (q == fast_dsp_rx_q) {
			struct fast_dsp_rx_msg msg;
			if (xQueueReceive(q, &msg, 0)) {
				dsp_fast_rx(msg.in, msg.in_len, msg.out, msg.out_len);
				++diag.rx_blocks_task;
			}
		} else if (q == fast_dsp_tx_q) {
			struct fast_dsp_tx_msg msg;
			if (xQueueReceive(q, &msg, 0)) {
				dsp_fast_tx(msg.in, msg.out, msg.len);
				++diag.tx_blocks_task;
			}
		}
		cyc2 = DWT->CYCCNT;
		diag.cycles_dsp += cyc2 - cyc1;
	}
}
